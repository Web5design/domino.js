<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>domino.js by jacomyal</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- A guy said once "Every JavaScript libraries must be included in its documentation, to let people play with it directly". Here it is: -->
    <script src="javascripts/domino.min.js"></script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">domino.js</h1>
        <p class="header">A JavaScript cascading controller for fast interactive Web interfaces prototyping</p>

        <ul>
          <li class="download"><a class="buttons strong" href="https://raw.github.com/jacomyal/domino.js/master/build/domino.min.js">domino.min.js</a></li>
          <li><a class="buttons github" href="https://github.com/jacomyal/domino.js">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/jacomyal">Alexis Jacomy</a> from <a class="header name" href="https://github.com/linkfluence">Linkfluence</a>.</p>


      </header>
      <section>
<h1 id="toc_0">domino.js</h1>

<p>Current version: <strong>v1.3.3</strong></p>

<p><em>domino.js</em> is a JavaScript cascading controller for fast interactive Web interfaces prototyping, developped by <a href="http://github.com/jacomyal">Alexis Jacomy</a> at <a href="http://github.com/linkfluence">Linkfluence</a>. It is released under the <a href="https://raw.github.com/jacomyal/domino.js/master/LICENSE.txt">MIT License</a>.</p>

<h3 id="toc_1">How to use it:</h3>

<p>To use it, clone the repository:</p>
<pre><code>git clone git@github.com:jacomyal/domino.js.git
</code></pre>
<p>The latest minified version is available here:</p>

<p><a href="https://raw.github.com/jacomyal/domino.js/master/build/domino.min.js">https://raw.github.com/jacomyal/domino.js/master/build/domino.min.js</a></p>

<p>You can also minify your own version with <a href="http://gruntjs.com/">Grunt</a>:</p>

<ul>
<li>First, install <a href="http://nodejs.org/">Node.js</a>, <a href="https://npmjs.org/">NPM</a> and <a href="http://gruntjs.com/installing-grunt">Grunt</a>.</li>
<li>Use <code>npm install</code> to install domino.js development dependencies.</li>
<li>Use <code>grunt</code> to successively lint sources, launch unit tests, and minify the code with <a href="https://github.com/mishoo/UglifyJS">Uglify</a>.</li>
</ul>

<h3 id="toc_2">Contributing:</h3>

<p>You can contribute by submitting <a href="http://github.com/jacomyal/domino.js/issues">issues tickets</a> and proposing <a href="http://github.com/jacomyal/domino.js/pulls">pull requests</a>. The changelog is accessible <a href="https://github.com/jacomyal/domino.js#changelog">here</a>.</p>

<hr />

<h2 id="toc_3">Navigation:</h2>

<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#modules">Modules</a></li>
<li><a href="#hacks">Hacks</a></li>
<li><a href="#services">Services</a></li>
<li><a href="#help">Help</a></li>
<li><a href="#specifications">Specifications summary</a></li>
<li><a href="#main_loop_inside_domino_js">Main loop: Inside <em>domino.js</em></a></li>
<li><a href="#scopes_management">Scopes management</a></li>
<li><a href="#logs_and_global_settings">Logs and global settings</a></li>
<li><a href="#killing">Killing instances and modules</a></li>
<li><a href="#structures">Structures</a></li>
</ul>

<hr />

<h2 id="introduction">Introduction <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p><strong><em>domino.js</em> is a JavaScript library to manage interactions in dashboards</strong>. It has been especially designed for iterative processes, to obtain quickly <strong>maintainable</strong> proofs of concepts.</p>

<p>The concept is pretty simple:</p>

<ol>
<li>First, you define your <strong>properties</strong> (that describe your data as well as all the minor counts/flags that define the state of your interface), and associate input and output events to each of them.</li>
<li>Then, you instanciate your <strong>modules</strong> (that basically define all the graphic components that display or make possible to modify the properties), through <em>domino.js</em>&#39;s modules factory, that will take care of all the connecting part.</li>
<li>Finally, when a module will dispatch an event, it will automatically update the related properties, and the modules that are listening to these properties&#39; output events. <strong>So you never have to connect two modules by yourself.</strong></li>
</ol>

<p>But the most important feature of <em>domino.js</em> is probably the possibility to add arbitrarily <strong>hacks</strong>. A hack is just a function bound to one or more events. This function will be executed in its own scope, and can update properties, call AJAX services, dispatch other events, and a lot more. So basically, <strong>it gives a strict and clear place to write all those sh*tty features that were not considered in your original design.</strong></p>

<p>It might be easier with <strong>examples</strong>. In the following one, we just declare a <em>boolean</em> property, named &quot;flag&quot;, and bind two modules on it - one to update it, and one to know when it is updated:</p>
<div class="highlight"><pre><span class="c1">// First, let&#39;s instanciate domino.js:</span>
<span class="kd">var</span> <span class="nx">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">domino</span><span class="p">({</span>
  <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span>
    <span class="c1">// We only declare one property, named &quot;flag&quot;, that will contain</span>
    <span class="c1">// a boolean value:</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;flag&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;flagUpdated&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateFlag&#39;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">});</span>

<span class="c1">// Here is the module that will modify the value:</span>
<span class="kd">function</span> <span class="nx">emettorModule</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">domino</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// We add a method to update easily the value:</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">updateFlag</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newFlagValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The method &quot;dispatchEvent&quot; from &quot;domino.module&quot; will trigger</span>
    <span class="c1">// the update in the domino.js instance. So, it will update the</span>
    <span class="c1">// value, and then check if anything is bound the any of the</span>
    <span class="c1">// output events, and trigger:</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="s1">&#39;updateFlag&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">flag</span><span class="o">:</span> <span class="o">!!</span><span class="nx">newFlagValue</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Here is the module that receive the events when the flag is</span>
<span class="c1">// updated.</span>
<span class="kd">function</span> <span class="nx">receptorModule</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">domino</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// We add a trigger on the &quot;flagUpdated&quot; event, that will just</span>
  <span class="c1">// display the new value:</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">triggers</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="s1">&#39;flagUpdated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dominoInstance</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;New flag value: &#39;</span><span class="o">+</span><span class="nx">dominoInstance</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;flag&#39;</span><span class="p">));</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Finally, we have to instanciate our modules:</span>
<span class="kd">var</span> <span class="nx">emettor</span> <span class="o">=</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">addModule</span><span class="p">(</span><span class="nx">emettorModule</span><span class="p">),</span>
    <span class="nx">receptor</span> <span class="o">=</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">addModule</span><span class="p">(</span><span class="nx">receptorModule</span><span class="p">);</span>

<span class="c1">// Now, let&#39;s test it:</span>
<span class="nx">emettor</span><span class="p">.</span><span class="nx">updateFlag</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>  <span class="c1">// log: &quot;New flag value: true&quot;</span>
<span class="nx">emettor</span><span class="p">.</span><span class="nx">updateFlag</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// log: &quot;New flag value: false&quot;</span>
</pre>
</div>

<p>Now, the following example is basically the same than the previous one. But instead of a <em>boolean</em>, our property is a <em>string</em>, and we do not want it to exceed 5 characters. So, we add a <strong>hack</strong> bound on the output event of our property, and that will check the length of our string, and truncate it if it is too long:</p>
<div class="highlight"><pre><span class="c1">// As previously, let&#39;s first instanciate domino.js:</span>
<span class="kd">var</span> <span class="nx">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">domino</span><span class="p">({</span>
  <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span>
    <span class="c1">// We only declare one property, named &quot;string&quot;, that will</span>
    <span class="c1">// contain a string value:</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;stringUpdated&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateString&#39;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nx">hacks</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;stringUpdated&#39;</span><span class="p">,</span>
      <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;The string has been truncated!&#39;</span><span class="p">);</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">string</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">});</span>

<span class="c1">// Here is the module that will dispatch</span>
<span class="kd">function</span> <span class="nx">emettorModule</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">domino</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// We add a method to update easily the value:</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">updateString</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">newStringValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="s1">&#39;updateString&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">string</span><span class="o">:</span> <span class="nx">newStringValue</span>
    <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Here is the module that receive the events when the string</span>
<span class="c1">// is updated.</span>
<span class="kd">function</span> <span class="nx">receptorModule</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">domino</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="c1">// We add a trigger on the &quot;stringUpdated&quot; event, that will</span>
  <span class="c1">// just display the new value:</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">triggers</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="s1">&#39;stringUpdated&#39;</span><span class="p">]</span> <span class="o">=</span>
    <span class="kd">function</span><span class="p">(</span><span class="nx">dominoInstance</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
        <span class="s1">&#39;New string value: &#39;</span><span class="o">+</span><span class="nx">dominoInstance</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;string&#39;</span><span class="p">)</span>
      <span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Finally, we have to instanciate our modules:</span>
<span class="kd">var</span> <span class="nx">emettor</span> <span class="o">=</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">addModule</span><span class="p">(</span><span class="nx">emettorModule</span><span class="p">),</span>
    <span class="nx">receptor</span> <span class="o">=</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">addModule</span><span class="p">(</span><span class="nx">receptorModule</span><span class="p">);</span>

<span class="c1">// Now, let&#39;s test it:</span>
<span class="nx">emettor</span><span class="p">.</span><span class="nx">updateString</span><span class="p">(</span><span class="s1">&#39;abc&#39;</span><span class="p">);</span>
  <span class="c1">// log: &quot;New string value: abc&quot;</span>
<span class="nx">emettor</span><span class="p">.</span><span class="nx">updateString</span><span class="p">(</span><span class="s1">&#39;abcdefghi&#39;</span><span class="p">);</span>
  <span class="c1">// log: &quot;New string value: abcdefghi&quot;</span>
  <span class="c1">//      &quot;The string has been truncated!&quot;</span>
  <span class="c1">//      &quot;New string value: abcde&quot;</span>
</pre>
</div>

<h2 id="properties">Properties <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>The minimal declaration of a property is just a unique string <strong>id</strong>. Here is the exhaustive list of all the other parameters you can add to describe your property:</p>

<ul>
<li><code>{string}</code> <strong>id</strong>:

<ul>
<li>The id of the property.</li>
</ul></li>
<li><code>{?string}</code> <strong>label</strong>:

<ul>
<li>The label of the property (the ID by default)</li>
</ul></li>
<li><code>{?(string|object)}</code> <strong>type</strong>:

<ul>
<li>Indicated the type of the property. Use &quot;?&quot; to specify a nullable property, and &quot;|&quot; for multiple valid types.</li>
</ul></li>
<li><code>{?*}</code> <strong>value</strong>:

<ul>
<li>The initial value of the property (obviously, it has to match the type).</li>
</ul></li>
<li><code>{?function}</code> <strong>setter</strong>:

<ul>
<li>Overrides the default property setter.</li>
</ul></li>
<li><code>{?function}</code> <strong>getter</strong>:

<ul>
<li>Overrides the default property getter.</li>
</ul></li>
<li><code>{?(string|array)}</code> <strong>triggers</strong>:

<ul>
<li>The list of events that can modify the property. Can be an array or the list of events separated by spaces.</li>
</ul></li>
<li><code>{?(string|array)}</code> <strong>dispatch</strong>:

<ul>
<li>The list of events that must be triggered after modification of the property. Can be an array or the list of events separated by spaces.</li>
</ul></li>
<li><code>{?string}</code> <strong>description</strong>:

<ul>
<li>Eventually a descriptions string that can be accessed through the <code>help()</code> instance method.</li>
</ul></li>
</ul>

<p>Here is a more complete example on how to declare string:</p>
<div class="highlight"><pre><span class="c1">// [...] inside the properties declaration:</span>
<span class="p">{</span>
  <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;stringLessThan5Chars&#39;</span><span class="p">,</span>
  <span class="nx">label</span><span class="o">:</span> <span class="s1">&#39;String less than 5 chars&#39;</span><span class="p">,</span>
  <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateStringLessThan5Chars&#39;</span><span class="p">,</span>
  <span class="c1">// In this example, we associate two output events to the</span>
  <span class="c1">// property. It is often useful - for example if you have to</span>
  <span class="c1">// reinitialize some data or call a service when one on ten</span>
  <span class="c1">// different properties is updated:</span>
  <span class="nx">dispatch</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;stringLessThan5CharsUpdate&#39;</span><span class="p">,</span> <span class="s1">&#39;aStringIsUpdated&#39;</span><span class="p">],</span>
  <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
  <span class="nx">setter</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// First, we check the length of the new value:</span>
    <span class="nx">val</span> <span class="o">=</span> <span class="nx">val</span><span class="p">.</span><span class="nx">length</span><span class="o">&gt;</span><span class="mi">5</span> <span class="o">?</span>
      <span class="nx">val</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="o">:</span>
      <span class="nx">val</span><span class="p">;</span>

    <span class="c1">// If the value has not changed, returning false will cancel</span>
    <span class="c1">// the update of this property, ie the output events</span>
    <span class="c1">// (&#39;stringLessThan5CharsUpdate&#39; and &#39;aStringIsUpdated&#39;) will</span>
    <span class="c1">// not be dispatched.</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">val</span> <span class="o">===</span> <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;stringLessThan5Chars&#39;</span><span class="p">))</span>
      <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">stringLessThan5Chars</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">},</span>
  <span class="c1">// Here, since the setter will be used to set the initial value,</span>
  <span class="c1">// the initial value will be &quot;abcde&quot; and not &quot;abcdefghi&quot;:</span>
  <span class="nx">value</span><span class="o">:</span> <span class="s1">&#39;abcdefghi&#39;</span>
<span class="p">}</span>
<span class="c1">// [...]</span>
</pre>
</div>

<p>It basically makes the same thing as in the second example, but without the use of a hack.</p>

<h2 id="modules">Modules <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>Most of the time, the <strong>modules</strong> represent each graphic components - <em>buttons</em> to dispatch events, <em>checkboxes</em> to represent <code>boolean</code> properties, etc... Exactly as it is for the properties, designing your modules atomically is one of the best ways to keep your code <em>maintainable</em>.</p>

<p>Any module must extend the <code>domino.module</code> basic class. This class has just the methods to listen to and dispatch events, and empty objects that you will fill with your <strong>triggers</strong>. You can bind a trigger on an <em>event</em> or directly to a <em>property</em> (it will then be triggered any time the property is effectively updated).</p>

<p>Here is a quick and pratical example using jQuery, of a module corresponding to an HTML <em>checkbox</em>, and representing the boolean property &quot;flag&quot; from the first example:</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">Checkbox</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">domino</span><span class="p">.</span><span class="nx">module</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

  <span class="kd">var</span> <span class="nx">self</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
      <span class="nx">html</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;fieldset&gt;&#39;</span> <span class="o">+</span>
                 <span class="s1">&#39;&lt;input type=&quot;checkbox&quot; id=&quot;flag&quot; /&gt;&#39;</span> <span class="o">+</span>
                 <span class="s1">&#39;&lt;label for=&quot;flag&quot;&gt;Flag&lt;/label&gt;&#39;</span> <span class="o">+</span>
               <span class="s1">&#39;&lt;/fieldset&gt;&#39;</span><span class="p">);</span>

  <span class="c1">// When the checkbox is clicked, it will update the &quot;flag&quot; in</span>
  <span class="c1">// domino, and dispatch output events:</span>
  <span class="nx">html</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">).</span><span class="nx">change</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">data</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">data</span><span class="p">[</span><span class="s1">&#39;flag&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">is</span><span class="p">(</span><span class="s1">&#39;:checked&#39;</span><span class="p">);</span>

    <span class="c1">// Dispatch the event</span>
    <span class="nx">self</span><span class="p">.</span><span class="nx">dispatchEvent</span><span class="p">(</span><span class="s1">&#39;updateFlag&#39;</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="c1">// When the &quot;flag&quot; is updated, we update the state of the</span>
  <span class="c1">// checkbox (&quot;self.triggers.properties[&#39;flag&#39;]&quot; could have</span>
  <span class="c1">// been used as well):</span>
  <span class="nx">self</span><span class="p">.</span><span class="nx">triggers</span><span class="p">.</span><span class="nx">events</span><span class="p">[</span><span class="s1">&#39;flagUpdated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">dominoInstance</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">html</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">).</span><span class="nx">attr</span><span class="p">(</span>
      <span class="s1">&#39;checked&#39;</span><span class="p">,</span>
      <span class="o">!</span><span class="nx">dominoInstance</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;flag&#39;</span><span class="p">)</span> <span class="o">?</span>
        <span class="s1">&#39;checked&#39;</span> <span class="o">:</span>
        <span class="kc">null</span>
    <span class="p">);</span>
  <span class="p">};</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">html</span> <span class="o">=</span> <span class="nx">html</span><span class="p">;</span>
<span class="p">};</span>
</pre>
</div>

<p>Once this module class is declared, if you want to add an instance to a DOM element, you just have to write:</p>
<div class="highlight"><pre><span class="c1">// with &quot;controller&quot; our domino.js instance, and &quot;dom&quot; the DOM parent:</span>
<span class="kd">var</span> <span class="nx">myCheckbox</span> <span class="o">=</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">addModule</span><span class="p">(</span><span class="nx">Checkbox</span><span class="p">);</span>
<span class="nx">myCheckbox</span><span class="p">.</span><span class="nx">html</span><span class="p">.</span><span class="nx">appendTo</span><span class="p">(</span><span class="nx">dom</span><span class="p">);</span>
</pre>
</div>

<p>And that&#39;s it, the module is here and connected. And you can even create two instances or more, and there will not be any conflict, and they will all stay synchronized, of course.</p>

<p>Also, it is possible to specify an id for a module. It is not possible to add two modules with the same id, the oldest one will have to be killed before. Also, the instance method <code>.modules()</code> can retrieve modules identified by the specified id.</p>

<p>Here is how to add a module with a specified id:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">addModule</span><span class="p">(</span><span class="nx">MyModuleConstructor</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;myModuleId&#39;</span> <span class="p">});</span>

<span class="c1">// Then, it is possible to get a reference to that module through</span>
<span class="c1">// the domino instance like that:</span>
<span class="nx">myModule</span> <span class="o">===</span> <span class="nx">controller</span><span class="p">.</span><span class="nx">modules</span><span class="p">(</span><span class="s1">&#39;myModuleId&#39;</span><span class="p">);</span> <span class="c1">// returns true</span>
</pre>
</div>

<h2 id="hacks">Hacks <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p><strong>Hacks</strong> are useful to implement all those features that you can not predict in the definition of your projects - they actually are real <em>hacks</em>. Here are some examples of the kind of &quot;features&quot; that can be a disaster for your code, but are easily implementable with <em>domino.js</em>:</p>

<ul>
<li>Restrict the max count of selected elements in a list to a specified number.</li>
<li>Hide some available values from a <em>select</em> module when another is updated.</li>
<li>Reset some properties when a <em>button</em> is clicked, and some other when another <em>button</em> is activated.</li>
<li>etc...</li>
</ul>

<p>Let&#39;s consider the following practical case: You have three different flags (properties <code>flag1</code>, <code>flag2</code> and <code>flag3</code>), and you want to have the three values always stored in an array (property <code>list</code>).</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">domino</span><span class="p">({</span>
  <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;flag1&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateFlag1&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;flag1Updated&#39;</span><span class="p">,</span> <span class="s1">&#39;flagUpdated&#39;</span><span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;flag2&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateFlag2&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;flag2Updated&#39;</span><span class="p">,</span> <span class="s1">&#39;flagUpdated&#39;</span><span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;flag3&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateFlag3&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;flag3Updated&#39;</span><span class="p">,</span> <span class="s1">&#39;flagUpdated&#39;</span><span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;listUpdated&#39;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nx">hacks</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;flagUpdated&#39;</span><span class="p">,</span>
      <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Here you can refresh the list:</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">list</span> <span class="o">=</span> <span class="p">[</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;flag1&#39;</span><span class="p">),</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;flag2&#39;</span><span class="p">),</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;flag3&#39;</span><span class="p">)</span>
        <span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">});</span>
</pre>
</div>

<p>And that&#39;s it: Any time one flag is updated, the list will automatically be refreshed, and the event &quot;listUpdated&quot; dispatched.</p>

<p>The different methods you can call from the hacks are described in the <strong><a href="#scopes_management">Scopes management</a></strong> section.</p>

<h3 id="toc_4">Specifications:</h3>

<p>Each hack must be an <code>object</code></p>

<ul>
<li><code>{string|array}</code> <strong>triggers</strong>:

<ul>
<li>At least one event that will trigger the hack.</li>
</ul></li>
<li><code>{?(string|array)}</code> <strong>dispatch</strong>:

<ul>
<li>Eventually one or more events that will be dispatched when the hack is triggered.</li>
</ul></li>
<li><code>{?function}</code> <strong>method</strong>:

<ul>
<li>Eventually a function that will be executed when the hack is triggered. It takes the event that triggered the hack as only parameter. Its scope is described in the <strong><a href="#scopes_management">Scopes management</a></strong> section.</li>
</ul></li>
<li><code>{?string}</code> <strong>description</strong>:

<ul>
<li>Eventually a descriptions string that will be logged when the hack is triggered.</li>
</ul></li>
</ul>

<h2 id="services">Services <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p><em>domino.js</em> provides an helper to interact with Web services. Basically, referencing a service will create a shortcut to call in an easy way you Web service.</p>

<p>Here is a basic example:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">domino</span><span class="p">({</span>
  <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;theProperty&#39;</span><span class="p">,</span>
      <span class="nx">label</span><span class="o">:</span> <span class="s1">&#39;The Property&#39;</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateTheProperty&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;thePropertyUpdated&#39;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nx">services</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;getTheProperty&#39;</span><span class="p">,</span>
      <span class="nx">setter</span><span class="o">:</span> <span class="s1">&#39;theProperty&#39;</span><span class="p">,</span>
      <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;/path/to/get/the/property&#39;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">});</span>
</pre>
</div>

<p>Then, executing <code>controller.request(&#39;getTheProperty&#39;);</code> will make a GET call to the indicated URL, set the received data as <code>theProperty</code> value, and dispatch a <code>&quot;thePropertyUpdated&quot;</code> event.</p>

<h3 id="toc_5">Shortcuts:</h3>

<p>Also, to help manipulating services, it is possible to use <strong>shortcuts</strong> to avoid declare explicitely lots of things. Here is an example:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">domino</span><span class="p">({</span>
  <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;prop1&#39;</span><span class="p">,</span>
      <span class="nx">label</span><span class="o">:</span> <span class="s1">&#39;Property 1&#39;</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateProp1&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;prop1Updated&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;prop2&#39;</span><span class="p">,</span>
      <span class="nx">label</span><span class="o">:</span> <span class="s1">&#39;Property 2&#39;</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateProp2&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;prop2Updated&#39;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nx">services</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;propN&#39;</span><span class="p">,</span>
      <span class="nx">setter</span><span class="o">:</span> <span class="s1">&#39;:property&#39;</span><span class="p">,</span>
      <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;/path/to/get/:property&#39;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">});</span>

<span class="c1">// Let&#39;s update prop1</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="s1">&#39;propN&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">shortcuts</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;prop1&#39;</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// Now, let&#39;s update prop2</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="s1">&#39;propN&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">shortcuts</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;prop2&#39;</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// Finally, the following line will throw an error, since :property</span>
<span class="c1">// can not be resolved:</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="s1">&#39;propN&#39;</span><span class="p">);</span>

<span class="c1">// Note that it is possible to throw several requests at the same time:</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">request</span><span class="p">([</span>
  <span class="p">{</span>
    <span class="nx">service</span><span class="o">:</span> <span class="s1">&#39;propN&#39;</span><span class="p">,</span>
    <span class="nx">shortcuts</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;prop1&#39;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="nx">service</span><span class="o">:</span> <span class="s1">&#39;propN&#39;</span><span class="p">,</span>
    <span class="nx">shortcuts</span><span class="o">:</span> <span class="p">{</span>
      <span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;prop2&#39;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="s1">&#39;propN&#39;</span>
<span class="p">]);</span>
</pre>
</div>

<p>Here is how <em>domino.js</em> resolves shortcuts:</p>

<ul>
<li>If there is a <code>shortcuts</code> object in the parameters given to the service when called, it will look if a value has been specified in it for the shortcut.</li>
<li>If not, it will check if there is a property named like the shortcut, and use its current value if it exists.</li>
<li>Then, if still not resolved, it will check if there is a shortcut declared in the instance with the same name, and use the returned value if it exists.</li>
<li>Finally, if the shortcut can not be resolved, then an error is thrown.</li>
</ul>

<p><em>Note</em>: It is possible to specify a <code>description</code> attribute for shortcuts, that can be accessed exactly as properties and services descriptions, through the <code>help()</code> instance method.</p>

<p>Here is an example with shortcuts declared directly in <em>domino.js</em> instance:</p>
<div class="highlight"><pre><span class="kd">var</span> <span class="nx">controller</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">domino</span><span class="p">({</span>
  <span class="nx">properties</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;prop&#39;</span><span class="p">,</span>
      <span class="nx">label</span><span class="o">:</span> <span class="s1">&#39;Property&#39;</span><span class="p">,</span>
      <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span><span class="p">,</span>
      <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span>
      <span class="nx">triggers</span><span class="o">:</span> <span class="s1">&#39;updateProp&#39;</span><span class="p">,</span>
      <span class="nx">dispatch</span><span class="o">:</span> <span class="s1">&#39;propUpdated&#39;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nx">services</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;prop&#39;</span><span class="p">,</span>
      <span class="nx">setter</span><span class="o">:</span> <span class="s1">&#39;prop&#39;</span><span class="p">,</span>
      <span class="nx">url</span><span class="o">:</span> <span class="s1">&#39;/path/to/get/property?date=:date&#39;</span>
    <span class="p">}</span>
  <span class="p">],</span>
  <span class="nx">shortcuts</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;date&#39;</span><span class="p">,</span>
      <span class="nx">method</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">domino</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()).</span><span class="nx">toString</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">});</span>
</pre>
</div>

<p>In this last example, when the service &#39;prop&#39; is called, the shortcut &#39;:date&#39; will be resolved as the current date.</p>

<h3 id="toc_6">Service specifications:</h3>

<p>Here is the list of attributes to precise a service:</p>

<ul>
<li><code>{string}</code> <strong>id</strong>:

<ul>
<li>The unique id of the service, used to specify which service to call.</li>
</ul></li>
<li><code>{string|function}</code> <strong>url</strong>:

<ul>
<li>The URL of the service. If a string, then any shortcut in it will be resolved. If a function, will be executed with the second argument given to <code>request</code>, and the returned string will also be resolved before the call.</li>
</ul></li>
<li><code>{?string}</code> <strong>contentType</strong>:

<ul>
<li>The AJAX query content-type.</li>
</ul></li>
<li><code>{?string}</code> <strong>dataType</strong>:

<ul>
<li>The AJAX query data-type.</li>
</ul></li>
<li><code>{?string}</code> <strong>type</strong>:

<ul>
<li>The AJAX call type (GET|POST|DELETE).</li>
</ul></li>
<li><code>{?(*|function)}</code> <strong>data</strong>:

<ul>
<li>The data sent in the AJAX call. Can be either an object or a function executed when <code>request</code> is called. Then, the object will be parsed, and shortcuts can be used in the first depth of the object.</li>
</ul></li>
<li><code>{?function}</code> <strong>error</strong>:

<ul>
<li>A function to execute if AJAX failed.</li>
</ul></li>
<li><code>{?function}</code> <strong>before</strong>:

<ul>
<li>A function to execute before calling AJAX.</li>
</ul></li>
<li><code>{?function}</code> <strong>success</strong>:

<ul>
<li>A function to execute if AJAX successed.</li>
</ul></li>
<li><code>{?function}</code> <strong>expect</strong>:

<ul>
<li>A function that will be triggered with the data, the input and the service configuration before triggering the <code>success</code> callback. If this method returns a falsy value, then the <code>success</code> will be skipped and the <code>error</code> callback will be triggered instead.</li>
<li>Also, this parameter can be set directly in the instance or global settings, under the key <code>expect</code>.</li>
</ul></li>
<li><code>{?string}</code> <strong>setter</strong>:

<ul>
<li>The name of a property. If the setter exists, then it will be called with the received data as parameter, or the value corresponding to the path, if specified. Shortcuts will be resolved.</li>
</ul></li>
<li><code>{?(string|array)}</code> <strong>path</strong>:

<ul>
<li>Indicates the path of the data to give to the setter, if specified (Example: <code>&quot;a.b.c&quot;</code>). Shortcuts will be resolved.</li>
</ul></li>
<li><code>{?(string|array)}</code> <strong>events</strong>:

<ul>
<li>The events to dispatch in case of success.</li>
</ul></li>
<li><code>{?string}</code> <strong>description</strong>:

<ul>
<li>Eventually a descriptions string that can be accessed through the <code>help()</code> instance method.</li>
</ul></li>
</ul>

<h3 id="toc_7">Request specifications:</h3>

<p>Finally, here is a precise description of the options given to the <code>request</code> method:</p>

<ul>
<li><code>{?string}</code> <strong>service</strong>:

<ul>
<li>The id of the service to call (if not given as first argument).</li>
</ul></li>
<li><code>{?boolean}</code> <strong>abort</strong>:

<ul>
<li>Indicates if the last call of the specified service has to be aborted if not ended.</li>
</ul></li>
<li><code>{?function}</code> <strong>before</strong>:

<ul>
<li>Overrides the original service &quot;before&quot; value.</li>
</ul></li>
<li><code>{?string}</code> <strong>contentType</strong>:

<ul>
<li>The contentType of the AJAX call.</li>
</ul></li>
<li><code>{?*}</code> <strong>data</strong>:

<ul>
<li>If the original service &quot;data&quot; attribute is not a function, then it will be overridden by this &quot;data&quot; value.</li>
</ul></li>
<li><code>{?string}</code> <strong>dataType</strong>:

<ul>
<li>The dataType of the AJAX call.</li>
</ul></li>
<li><code>{?function}</code> <strong>error</strong>:

<ul>
<li>Overrides the original service &quot;error&quot; value.</li>
</ul></li>
<li><code>{?array|string}</code> <strong>events</strong>:

<ul>
<li>Adds more events to dispatch when the &quot;success&quot; is called.</li>
</ul></li>
<li><code>{?object}</code> <strong>params</strong>:

<ul>
<li>The pairs (key/value) in this object will override the shortcuts.</li>
</ul></li>
<li><code>{?string}</code> <strong>path</strong>:

<ul>
<li>Overrides the original service &quot;path&quot; value.</li>
</ul></li>
<li><code>{?string}</code> <strong>setter</strong>:

<ul>
<li>Overrides the original service &quot;setter&quot; value.</li>
</ul></li>
<li><code>{?function}</code> <strong>success</strong>:

<ul>
<li>Overrides the original service &quot;success&quot; value.</li>
</ul></li>
<li><code>{?function}</code> <strong>expect</strong>:

<ul>
<li>Overrides the original service &quot;expect&quot; value.</li>
</ul></li>
<li><code>{?string}</code> <strong>type</strong>:

<ul>
<li>Overrides the AJAX call type (GET|POST|DELETE).</li>
</ul></li>
</ul>

<h2 id="help">Help <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>When descriptions are specified for properties, shortcuts, hacks and/or services, the method <code>help()</code> of the domino instance can retrieve these descriptions. Here are some use cases of this method:</p>
<div class="highlight"><pre><span class="c1">// The two following test cases work exactly samely for shortcuts</span>
<span class="c1">// and services:</span>
<span class="nx">domInst</span><span class="p">.</span><span class="nx">help</span><span class="p">(</span><span class="s1">&#39;properties&#39;</span><span class="p">,</span> <span class="s1">&#39;myProperty1&#39;</span><span class="p">);</span>
<span class="c1">// Returns something like: &#39;Description of myProperty1&#39;</span>
<span class="nx">domInst</span><span class="p">.</span><span class="nx">help</span><span class="p">(</span><span class="s1">&#39;properties&#39;</span><span class="p">);</span>
<span class="c1">// Returns something like:</span>
<span class="c1">// {</span>
<span class="c1">//   myProperty1: &#39;Description of myProperty1&#39;,</span>
<span class="c1">//   myProperty2: &#39;Description of myProperty2&#39;,</span>
<span class="c1">//   myProperty3: &#39;[no description is specified]&#39;</span>
<span class="c1">// }</span>

<span class="c1">// Here is how it works for hacks:</span>
<span class="nx">domInst</span><span class="p">.</span><span class="nx">help</span><span class="p">(</span><span class="s1">&#39;hacks&#39;</span><span class="p">,</span> <span class="s1">&#39;trigger&#39;</span><span class="p">,</span> <span class="s1">&#39;myEvent1&#39;</span><span class="p">);</span>
<span class="c1">// Returns something like:</span>
<span class="c1">// [</span>
<span class="c1">//   &#39;Description of my hack n°1&#39;,</span>
<span class="c1">//   &#39;Description of my hack n°2&#39;</span>
<span class="c1">// ]</span>
<span class="nx">domInst</span><span class="p">.</span><span class="nx">help</span><span class="p">(</span><span class="s1">&#39;hacks&#39;</span><span class="p">,</span> <span class="s1">&#39;dispatch&#39;</span><span class="p">,</span> <span class="s1">&#39;myEvent2&#39;</span><span class="p">);</span>
<span class="c1">// Returns something like: &#39;Description of my hack n°1&#39;</span>
<span class="nx">domInst</span><span class="p">.</span><span class="nx">help</span><span class="p">(</span><span class="s1">&#39;hacks&#39;</span><span class="p">);</span>
<span class="c1">// Returns something like:</span>
<span class="c1">// [</span>
<span class="c1">//   &#39;Description of my hack n°1&#39;,</span>
<span class="c1">//   &#39;Description of my hack n°2&#39;,</span>
<span class="c1">//   &#39;Description of my hack n°3&#39;</span>
<span class="c1">// ]</span>

<span class="c1">// Finally, it is possible to display everything:</span>
<span class="nx">domInst</span><span class="p">.</span><span class="nx">help</span><span class="p">(</span><span class="s1">&#39;full&#39;</span><span class="p">);</span>
<span class="c1">// Returns something like:</span>
<span class="c1">// {</span>
<span class="c1">//   properties: {</span>
<span class="c1">//     myProperty1: &#39;Description of myProperty1&#39;,</span>
<span class="c1">//     myProperty2: &#39;Description of myProperty2&#39;,</span>
<span class="c1">//     myProperty3: &#39;[no description is specified]&#39;</span>
<span class="c1">//   },</span>
<span class="c1">//   services: {</span>
<span class="c1">//     myService1: &#39;Description of myService1&#39;,</span>
<span class="c1">//     myService2: &#39;Description of myService2&#39;,</span>
<span class="c1">//     myService3: &#39;[no description is specified]&#39;</span>
<span class="c1">//   },</span>
<span class="c1">//   shortcuts: {</span>
<span class="c1">//     myShortcut1: &#39;Description of myShortcut1&#39;,</span>
<span class="c1">//     myShortcut2: &#39;Description of myShortcut2&#39;,</span>
<span class="c1">//     myShortcut3: &#39;[no description is specified]&#39;</span>
<span class="c1">//   },</span>
<span class="c1">//   hacks: [</span>
<span class="c1">//     &#39;Description of my hack n°1&#39;,</span>
<span class="c1">//     &#39;Description of my hack n°2&#39;,</span>
<span class="c1">//     &#39;Description of my hack n°3&#39;</span>
<span class="c1">//   ]</span>
<span class="c1">// }</span>
</pre>
</div>

<h2 id="specifications">Specifications summary <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>Here is a summary of the specifications of <em>domino.js</em> instanciation:</p>

<ul>
<li><code>{?string}</code> <strong>name</strong></li>
<li><code>{?array}</code> <strong>properties</strong>: Each element of the array must be an <code>object</code> with:

<ul>
<li><code>{string}</code> <strong>id</strong></li>
<li><code>{?string}</code> <strong>label</strong></li>
<li><code>{?(string|object)}</code> <strong>type</strong></li>
<li><code>{?*}</code> <strong>value</strong></li>
<li><code>{?function}</code> <strong>setter</strong></li>
<li><code>{?function}</code> <strong>getter</strong></li>
<li><code>{?(string|array)}</code> <strong>triggers</strong></li>
<li><code>{?(string|array)}</code> <strong>dispatch</strong></li>
<li><code>{?string}</code> <strong>description</strong></li>
</ul></li>
<li><code>{?array}</code> <strong>hacks</strong>: Each element of the array must be an <code>object</code> with:

<ul>
<li><code>{string|array}</code> <strong>triggers</strong></li>
<li><code>{?(string|array)}</code> <strong>dispatch</strong></li>
<li><code>{?function}</code> <strong>method</strong></li>
<li><code>{?string}</code> <strong>description</strong></li>
</ul></li>
<li><code>{?array}</code> <strong>services</strong>: Each element of the array must be an <code>object</code> with:

<ul>
<li><code>{string}</code> <strong>id</strong></li>
<li><code>{string|function}</code> <strong>url</strong></li>
<li><code>{?string}</code> <strong>contentType</strong></li>
<li><code>{?string}</code> <strong>dataType</strong></li>
<li><code>{?string}</code> <strong>type</strong></li>
<li><code>{?(*|function)}</code> <strong>data</strong></li>
<li><code>{?function}</code> <strong>error</strong></li>
<li><code>{?function}</code> <strong>before</strong></li>
<li><code>{?function}</code> <strong>success</strong></li>
<li><code>{?function}</code> <strong>expect</strong></li>
<li><code>{?string}</code> <strong>setter</strong></li>
<li><code>{?(string|array)}</code> <strong>path</strong></li>
<li><code>{?(string|array)}</code> <strong>events</strong></li>
<li><code>{?string}</code> <strong>description</strong></li>
</ul></li>
<li><code>{?array}</code> <strong>shortcuts</strong>: Each element of the array must be an <code>object</code> with:

<ul>
<li><code>{string}</code> <strong>id</strong></li>
<li><code>{function}</code> <strong>method</strong></li>
<li><code>{?string}</code> <strong>description</strong></li>
</ul></li>
</ul>

<h2 id="main_loop_inside_domino_js">Main loop: Inside <em>domino.js</em> <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>The core function in <em>domino.js</em> manages the events chain.</p>

<p>Basically, when an event is dispatched from a module, it will trigger this loop. Then, the related properties will be updated, any module or hack listening to this event will be triggered - causing eventually new updates. After all these actions, new events are to be triggered. <strong>So the loop we be called again</strong>, but with all those new events instead of the one from the module, etc.</p>

<p>This same loop is also called as an output for services success and error function, and the global <code>update</code> method (accessible only through the <em>domino.js</em> instance itself).</p>

<p>Here is an example:</p>
<pre><code>(module) -> updateProp -> event1 -> hack1 -> event3
                       -> event2 -> hack2 -> event4
</code></pre>
<p>Here, a module updates the property <code>prop</code> which dispatches events <code>event1</code> and <code>event2</code>. Hack <code>hack1</code> is triggered on <code>event1</code>, and hack <code>hack2</code> is triggered on <code>event2</code>. Finally, <code>hack1</code> dispatches <code>event3</code> and <code>hack2</code> dispatches <code>event4</code>.</p>

<p>The problem here is that, with a classic synchronous events management system, <code>event3</code> would be dispatched <strong>before</strong> <code>event2</code>, when it is expected to be triggered &quot;later&quot;.</p>

<p><strong>The <em>domino.js</em>&#39;s main loop resolves this issue</strong> by executing the previous events chain as following:</p>
<pre><code>(module) -> updateProp -> event1, event2 -> hack1, hack2 -> event3, event4
</code></pre>
<p>And even better: <strong>when an event is about to be triggered twice or more, it is dispatched only once instead</strong>.</p>

<p>For example, the following chain:</p>
<pre><code>(module) -> updateProp -> event1 -> hack1 -> event3
                       -> event2 -> hack2 -> event3
</code></pre>
<p>... will become:</p>
<pre><code>(module) -> updateProp -> event1, event2 -> hack1, hack2 -> event3
</code></pre>
<h2 id="scopes_management">Scopes management <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>There is a lot of functions given to <em>domino.js</em> through the initial configuration and the modules. One particularity of <em>domino.js</em> is that these methods are called in a specific scope, that contains safe accesses to different properties, and tools to display logs.</p>

<p>Also, for some type of functions, some other parameters or values can be added in the scope - and some parameters can be added or modified directly in the scope - something like:</p>
<div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">anyProperty</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</pre>
</div>

<h3 id="toc_8">Default scope methods:</h3>

<p>Here is the default methods that any of the functions you give to <em>domino.js</em> will find in its scope.</p>

<ul>
<li><p><strong>get</strong> <em>(property, args...)</em></p>

<ul>
<li>Returns the current value of the specified property. The additional parameters are given to the getter, if this one has been customly defined.</li>
</ul></li>
<li><p><strong>expand</strong> <em>(shortcutId)</em></p>

<ul>
<li>Execute the specified shortcut, and returns the result.</li>
</ul></li>
<li><p><strong>log</strong> <em>(args...)</em></p>

<ul>
<li>If domino global setting <code>verbose</code> is true, will display the arguments in the console, with the <code>domino.js</code> instance name as prefix.</li>
</ul></li>
<li><p><strong>warn</strong> <em>(message)</em></p>

<ul>
<li>If domino global setting <code>strict</code> is true, will throw a &quot;message&quot; error, with the <code>domino.js</code> instance name as prefix. Else, if domino global setting <code>verbose</code> is true, will display &quot;message&quot; in the console, with the <code>domino.js</code> instance name as prefix.</li>
</ul></li>
<li><p><strong>die</strong> <em>(message)</em></p>

<ul>
<li>Throws a &quot;message&quot; error, with the <code>domino.js</code> instance name as prefix.</li>
</ul></li>
<li><p><strong>getEvents</strong> <em>(property)</em></p>

<ul>
<li>Returns the array of events that the <code>domino.js</code> instance listen to update the specified property.</li>
</ul></li>
<li><p><strong>getLabel</strong> <em>(property)</em></p>

<ul>
<li>Returns the label of the specified property.</li>
</ul></li>
</ul>

<h3 id="toc_9">Additional methods:</h3>

<p>Also, some functions you will give to <em>domino.js</em> will have access to some more methods, that can update properties or call AJAX services. Here is the list of thoses methods:</p>

<ul>
<li><p><strong>request</strong> <em>(serviceId, options)</em></p>

<ul>
<li>Calls the specified service. Check the <strong>Services</strong> documentation to see which options you can use.</li>
</ul></li>
<li><p><strong>dispatchEvent</strong> <em>(eventType, data)</em></p>

<ul>
<li>Dispatches the specified event. Warning: Despite it works like <code>domino.EventDispatcher.dispatchEvent</code>, it is not the same implementation, and the event will be considered by the <em>domino.js</em> instance after the complete execution of your function.</li>
</ul></li>
<li><p><strong>addModule</strong> <em>(class, options)</em></p>

<ul>
<li>Instanciate the specified module, plugs all the event connections, and returns the module instance.</li>
</ul></li>
<li><p><strong>update</strong> <em>({String|Object}, ?</em>)*</p>

<ul>
<li>If the given parameter is an <code>Object</code>, then each <em>key/value</em> pair will set the <em>value</em> to the <em>key</em> property. If called with two arguments, then the first must be the property name, and the second one the new value.</li>
</ul></li>
</ul>

<p><strong>Important</strong>: All the methods described (the default and the additional ones) are also available in the object returned by the <em>domino.js</em> constructor itself. Also, the default scope is always given as the <strong>first</strong> parameter to the modules constructors.</p>

<h3 id="toc_10">Functions given to domino:</h3>

<p>Here is the list of every types of functions you can give to <em>domino.js</em>, with the related specifications (what you can modify directly in the scope, which parameters are given, which additional methods are available):</p>

<ul>
<li><p><strong>Hacks</strong>:</p>

<ul>
<li>Additional methods in the scope:

<ul>
<li><em>request</em></li>
<li><em>dispatchEvent</em></li>
</ul></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>Object</code>] The event that triggered the hack</li>
</ul></li>
<li>Accepted scope modifications:

<ul>
<li>[<code>*</code>] this[property] will update <em>property</em></li>
</ul></li>
<li>Returns: <em>(not evaluated)</em></li>
</ul></li>
<li><p><strong>Triggers (in modules)</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>Object</code>] The domino scope</li>
<li>[<code>Object</code>] The dispatched event</li>
</ul></li>
<li>Accepted scope modifications: <em>(none)</em></li>
<li>Returns: <em>(not evaluated)</em></li>
</ul></li>
<li><p><strong>Service &quot;success&quot;</strong>:</p>

<ul>
<li>Additional methods in the scope:

<ul>
<li><em>request</em></li>
<li><em>dispatchEvent</em></li>
</ul></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>Object</code>] The data received from AJAX</li>
<li>[<code>?Object</code>] The params given to the service when called</li>
</ul></li>
<li>Accepted scope modifications:

<ul>
<li>[<code>*</code>] this[property] will update <em>property</em></li>
</ul></li>
<li>Returns: <em>(not evaluated)</em></li>
</ul></li>
<li><p><strong>Service &quot;error&quot;</strong>:</p>

<ul>
<li>Additional methods in the scope:

<ul>
<li><em>request</em></li>
<li><em>dispatchEvent</em></li>
</ul></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>String</code>] The error message</li>
<li>[<code>Object</code>] The related XHR object</li>
<li>[<code>?Object</code>] The params given to the service when called</li>
</ul></li>
<li>Accepted scope modifications:

<ul>
<li>[<code>*</code>] this[property] will update <em>property</em></li>
</ul></li>
<li>Returns: <em>(not evaluated)</em></li>
</ul></li>
<li><p><strong>Service &quot;before&quot;</strong>:</p>

<ul>
<li>Additional methods in the scope:

<ul>
<li><em>dispatchEvent</em></li>
</ul></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>?Object</code>] The params given to the service when called</li>
</ul></li>
<li>Accepted scope modifications:

<ul>
<li>[<code>*</code>] this[property] will update <em>property</em></li>
</ul></li>
<li>Returns: <em>(not evaluated)</em></li>
</ul></li>
<li><p><strong>Service &quot;expect&quot;</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>Object</code>] The data received from AJAX</li>
<li>[<code>?Object</code>] The params given to the service when called</li>
<li>[<code>Object</code>] The service configuration object</li>
</ul></li>
<li>Accepted scope modifications: <em>(none)</em></li>
<li>Returns:

<ul>
<li>[<code>Boolean</code>] <code>true</code> if the success method can be called, <code>false</code> else</li>
</ul></li>
</ul></li>
<li><p><strong>Service &quot;url&quot;</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>?Object</code>] The params given to the service when called</li>
</ul></li>
<li>Accepted scope modifications: <em>(none)</em></li>
<li>Returns:

<ul>
<li>[<code>String</code>] The final URL</li>
</ul></li>
</ul></li>
<li><p><strong>Service &quot;data&quot;</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters:

<ul>
<li>[<code>?Object</code>] The params given to the service when called</li>
</ul></li>
<li>Accepted scope modifications: <em>(none)</em></li>
<li>Returns:

<ul>
<li>[<code>*</code>] The data sent through the AJAX call</li>
</ul></li>
</ul></li>
<li><p><strong>Shortcuts</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope: <em>(none)</em></li>
<li>Function parameters: <em>(none)</em></li>
<li>Accepted scope modifications: <em>(none)</em></li>
<li>Returns:

<ul>
<li>[<code>*</code>] Anything you want, that&#39;s the point of the shortcuts</li>
</ul></li>
</ul></li>
<li><p><strong>Custom setters</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope:

<ul>
<li>[<code>*</code>] this[property] contains the current value of the property</li>
</ul></li>
<li>Function parameters:

<ul>
<li>[<code>*</code>] The new value</li>
</ul></li>
<li>Accepted scope modifications:

<ul>
<li>[<code>*</code>] this[property] contains the new value of the property</li>
</ul></li>
<li>Returns:

<ul>
<li>[<code>?boolean</code>] If you return a boolean value, the property will be updated and the related events dispatched only if the returned boolean is <code>true</code></li>
</ul></li>
</ul></li>
<li><p><strong>Custom getters</strong>:</p>

<ul>
<li>Additional methods in the scope: <em>(none)</em></li>
<li>Parameters given through the scope:

<ul>
<li>[<code>*</code>] this[property] contains the current value of the property</li>
</ul></li>
<li>Function parameters: <em>(none)</em></li>
<li>Accepted scope modifications: <em>(none)</em></li>
<li>Returns:

<ul>
<li>[<code>*</code>] The current value of the property</li>
</ul></li>
</ul></li>
</ul>

<h2 id="logs_and_global_settings">Logs and global settings <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p>The global method <code>domino.settings</code> is used to manage global <em>domino.js</em> settings. It works like most <em>jQuery</em> methods:</p>

<ul>
<li><code>domino.settings(setting)</code>: Will return the <code>setting</code> value if it exists, <code>undefined</code> otherwise.</li>
<li><code>domino.settings(setting, value)</code>: Will set <code>value</code> in <code>setting</code> and return the global <em>domino</em> object.</li>
<li><code>domino.settings(obj)</code>: Will set for each <code>{key, value}</code> in <code>obj</code> the value <code>value</code> in the setting <code>key</code>, and return the global <em>domino</em> object.</li>
</ul>

<p>Here is the list of currently recognized global settings:</p>

<ul>
<li><strong>strict</strong>: If <code>true</code>, warnings are considered as errors (default: <code>false</code>).</li>
<li><strong>verbose</strong>: If <code>true</code>, logs will be sent in <code>console.log</code> (default: <code>false</code>).</li>
<li><strong>shortcutPrefix</strong>: Determines the shortcuts prefix (default: <code>&quot;:&quot;</code>).</li>
<li><strong>displayTime</strong>: If <code>true</code>, logs will be prefixed by the time since <em>domino.js</em> initialization, in milliseconds (default: <code>false</code>).</li>
<li><strong>logDescriptions</strong>: If <code>true</code>, hacks description will be logged when the related hacks are triggered (default: <code>true</code>).</li>
<li><strong>maxDepth</strong>: If a positive number (say <code>N</code>), if a loop exceeds the <code>N</code>-th iteration, domino throws an error (default: <code>0</code>).</li>
<li><strong>mergeRequests</strong>:

<ul>
<li>If <code>true</code>, when several requests are called at the same time, domino will wait for each of them to succeed before starting a unique loop, instead of starting one loop for each service (default: <code>true</code>).</li>
<li>Several calls are sent at the same time when:

<ul>
<li>An array is given as first argument to the method <code>request</code></li>
<li>The method <code>request</code> is called several time in the same callback (hack, success, etc...)</li>
</ul></li>
</ul></li>
<li><strong>clone</strong>:

<ul>
<li>If <code>true</code>, getters return always clone of the values, and setters clone values before they actually update values, using the <code>domino.utils.clone()</code> method. It might decrease <em>domino.js</em> performances, but makes data manipulation safer. More precisely, when clone mode is activated, there is no properties update without the related events (default: <code>true</code>).</li>
</ul></li>
</ul>

<p>Also, <em>domino.js</em> provides its own functions to log, warn or throw errors:</p>

<ul>
<li><code>die(args...)</code> will concatenate the arguments casts as strings and throw the result as an error.</li>
<li><code>log(args...)</code> will call <code>console.log(args...)</code> if the global setting <code>verbose</code> is true.</li>
<li><code>warn(args...)</code> will call <code>die(args...)</code> if the global setting <code>strict</code> is true, <code>log(args...)</code> otherwise.</li>
</ul>

<p>Finally, all the logs/warns/errors will be prefixed by the instance name if specified (the string <code>&quot;domino&quot;</code> otherwise).</p>

<h2 id="killing">Killing instances and modules <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<h3 id="toc_11">Killing modules:</h3>

<p>It is possible to destroy a module by calling the method <code>killModule()</code> of the related domino instance. It will basically destroy every ascending or descending connections between the module and the instance:</p>
<div class="highlight"><pre><span class="c1">// Kill the module:</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">killModule</span><span class="p">(</span><span class="nx">myModule</span><span class="p">);</span>
</pre>
</div>

<p>If the module has an <code>id</code> field specified, it is also possible to kill it through its id:</p>
<div class="highlight"><pre><span class="c1">// Kill the module:</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">killModule</span><span class="p">(</span><span class="s1">&#39;myModuleId&#39;</span><span class="p">);</span>
</pre>
</div>

<h3 id="toc_12">Killing a domino instance:</h3>

<p>Also, it is possible to kill a domino instance, by calling its method <code>kill()</code>. It will basically remove every external reference in the instance, and destroy every connections with eventually existing modules. Also, if the instance as a name, it will be possible again to call an instance with the same name.</p>
<div class="highlight"><pre><span class="c1">// Kill the instance:</span>
<span class="nx">controller</span><span class="p">.</span><span class="nx">kill</span><span class="p">();</span>
</pre>
</div>

<h2 id="structures">Structures <a href="#" class="right" title="Back to the top">(&uarr;)</a></h2>

<p><em>domino.js</em> provides its own helpers to manipulate some &quot;Closure like&quot; types in the <code>domino.struct</code> object. Since they can be more complex than simple string types, they are called <strong>structures</strong>.</p>

<p>Those structures are:</p>

<ul>
<li>Basic types:

<ul>
<li>&#39;boolean&#39;, &#39;number&#39;, &#39;string&#39;, &#39;function&#39;, &#39;array&#39;, &#39;date&#39;, &#39;regexp&#39;, &#39;object&#39;, &#39;null&#39;, &#39;undefined&#39;, &#39;*&#39;</li>
</ul></li>
<li>Optional types: <strong>&#39;?{type}&#39;</strong>

<ul>
<li>Example: <code>&#39;?object&#39;</code>, <code>&#39;?array&#39;</code>, etc...</li>
</ul></li>
<li>Multi-types: <strong>&#39;{type1}|{type2}&#39;</strong>

<ul>
<li>Example: <code>&#39;string|number&#39;</code>, <code>&#39;?array|object&#39;</code>, etc...</li>
</ul></li>
<li>Arrays: <strong>[type]</strong>

<ul>
<li>The array structure definition must be an array with exactly one value, which must be a valid structure descriptor. Then, any array containing only elements matching this structure is valid.</li>
<li>Examples:

<ul>
<li><code>[&#39;boolean&#39;]</code></li>
<li><code>[{ obj1: { k1: &#39;number&#39;, k2: &#39;number&#39; }, obj2: &#39;object&#39;, list: &#39;?array&#39; }]</code></li>
</ul></li>
</ul></li>
<li>Complex structures: <strong>{ key1: {type1}, key2: {type2} }</strong>

<ul>
<li>Examples:

<ul>
<li><code>{ a: &#39;number&#39;, b: &#39;number&#39;, total: &#39;?number&#39; }</code></li>
<li><code>{ obj1: { k1: &#39;number&#39;, k2: &#39;number&#39; }, obj2: &#39;object&#39; }</code></li>
</ul></li>
</ul></li>
</ul>

<p>Except for <code>&#39;undefined&#39;</code> and <code>&#39;null&#39;</code>, all the previously described structures are valid to characterize a property.</p>

<p>Here the list of the available functions to manipulate those structures:</p>

<ul>
<li><strong>get(value)</strong>: Returns the string structure of the value:</li>
</ul>
<div class="highlight"><pre><span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>      <span class="c1">// &#39;null&#39;</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="kc">undefined</span><span class="p">);</span> <span class="c1">// &#39;undefined&#39;</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>        <span class="c1">// &#39;number&#39;</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;toto&#39;</span><span class="p">);</span>    <span class="c1">// &#39;string&#39;</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">get</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>    <span class="c1">// &#39;object&#39;</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">get</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>   <span class="c1">// &#39;array&#39;</span>
</pre>
</div>

<ul>
<li><strong>check(struct, value)</strong>: Check if the value matches the specified structure:</li>
</ul>
<div class="highlight"><pre><span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">},</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span> <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>      <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">(</span><span class="s1">&#39;?object&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>     <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>           <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;?number&#39;</span><span class="p">},</span> <span class="p">{});</span>    <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">});</span>           <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">},</span> <span class="p">{});</span>     <span class="c1">// false</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">([</span><span class="s1">&#39;number&#39;</span><span class="p">],</span> <span class="p">[]);</span>        <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">([</span><span class="s1">&#39;number&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]);</span>       <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">([</span><span class="s1">&#39;number&#39;</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]);</span>    <span class="c1">// true</span>
</pre>
</div>

<ul>
<li><strong>isValid(struct)</strong>: Indicates whether the structure is a valid property structure:</li>
</ul>
<div class="highlight"><pre><span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">});</span>   <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">([{</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">}]);</span> <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">);</span>        <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">(</span><span class="s1">&#39;?object&#39;</span><span class="p">);</span>       <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">(</span><span class="s1">&#39;?object|array&#39;</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">(</span><span class="s1">&#39;?object|&#39;</span><span class="p">);</span>      <span class="c1">// false</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">(</span><span class="s1">&#39;undefined&#39;</span><span class="p">);</span>     <span class="c1">// false</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">isValid</span><span class="p">(</span><span class="s1">&#39;null&#39;</span><span class="p">);</span>          <span class="c1">// false</span>
</pre>
</div>

<ul>
<li><strong>deepScalar(struct)</strong>: Indicates whether the structure is deeply composed of scalar types. This helper is particularly useful to know if it is possible to easily compare two values of the structure (without any reference issue):</li>
</ul>
<div class="highlight"><pre><span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">);</span>        <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">(</span><span class="s1">&#39;?number&#39;</span><span class="p">);</span>       <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">([</span><span class="s1">&#39;?number&#39;</span><span class="p">]);</span>     <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">(</span><span class="s1">&#39;string|number&#39;</span><span class="p">);</span> <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">({</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">});</span>   <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">([{</span><span class="nx">a</span><span class="o">:</span> <span class="s1">&#39;number&#39;</span><span class="p">}]);</span> <span class="c1">// true</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">(</span><span class="s1">&#39;object&#39;</span><span class="p">);</span>        <span class="c1">// false</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">(</span><span class="s1">&#39;?object&#39;</span><span class="p">);</span>       <span class="c1">// false</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">deepScalar</span><span class="p">(</span><span class="s1">&#39;object|number&#39;</span><span class="p">);</span> <span class="c1">// false</span>
</pre>
</div>

<p>Also, <strong>it is possible to define globally structures</strong>, with the method <code>domino.struct.add()</code>. This makes possible to use recursive structures, and to avoid declaring several times the same structures in different instances of <em>domino.js</em>. Also, it is possible to define abstract structures with just a method that can determine wether any value matches the structure or not.</p>

<p>This method can be used by different ways:</p>

<ul>
<li><code>domino.struct.add( id, struct )</code>:

<ul>
<li><strong>id</strong> (<code>string</code>):</li>
<li><strong>struct</strong> (<code>*|function</code>):</li>
</ul></li>
<li><code>domino.struct.add( obj )</code>

<ul>
<li><strong>obj</strong> (<code>object</code>): Must contain <code>id</code> and <code>struct</code>. Can also have a <code>proto</code> value.</li>
</ul></li>
</ul>

<p>Here are some examples:</p>
<div class="highlight"><pre><span class="c1">// Here is how to add the &quot;integer&quot; structure:</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// v===+v  tests if the value is a number</span>
  <span class="c1">// v===~~v tests if the value is an integer</span>
  <span class="k">return</span> <span class="nx">v</span><span class="o">===+</span><span class="nx">v</span> <span class="o">&amp;&amp;</span> <span class="nx">v</span><span class="o">===~~</span><span class="nx">v</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Here are some tests:</span>
<span class="p">[</span>
  <span class="mi">123</span><span class="p">,</span>
  <span class="o">-</span><span class="mi">24</span><span class="p">,</span>
  <span class="mf">12.4</span><span class="p">,</span>
  <span class="s1">&#39;12&#39;</span><span class="p">,</span>
  <span class="s1">&#39;12.4&#39;</span><span class="p">,</span>
  <span class="s1">&#39;twelve&#39;</span>
<span class="p">].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span>
    <span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">(</span><span class="s1">&#39;integer&#39;</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span> <span class="o">?</span>
      <span class="nx">v</span> <span class="o">+</span> <span class="s1">&#39; is an integer&#39;</span> <span class="o">:</span>
      <span class="nx">v</span> <span class="o">+</span> <span class="s1">&#39; is not an integer&#39;</span>
  <span class="p">);</span>
<span class="p">});</span>

<span class="c1">// Here is another example, more data-oriented:</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">add</span><span class="p">({</span>
  <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;user&#39;</span><span class="p">,</span>
  <span class="nx">struct</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">login</span><span class="o">:</span> <span class="s1">&#39;string&#39;</span><span class="p">,</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;?string&#39;</span><span class="p">,</span>
    <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;string&#39;</span><span class="p">]</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// Here are some tests:</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">check</span><span class="p">(</span><span class="s1">&#39;user&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">login</span><span class="o">:</span> <span class="s1">&#39;bwayne&#39;</span><span class="p">,</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;Bruce Wayne&#39;</span><span class="p">,</span>
  <span class="nx">friends</span><span class="o">:</span> <span class="p">[</span>
    <span class="s1">&#39;batman&#39;</span><span class="p">,</span>
    <span class="s1">&#39;apennyworth&#39;</span>
  <span class="p">]</span>
<span class="p">});</span>
</pre>
</div>

<p>The parameter <code>&#39;proto&#39;</code> will indicates structures that must be considered as valid, event if they are not already created - only interesting if you need to use multi recursive structures, as in the following example:</p>
<div class="highlight"><pre><span class="c1">// &quot;struct1&quot; describes an array of &quot;struct2&quot; elements. Since &quot;struct2&quot; is not</span>
<span class="c1">// defined yet, it is declared in &quot;proto&quot; values, to avoid &quot;Wrong type error&quot;.</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">add</span><span class="p">({</span>
  <span class="nx">id</span><span class="o">:</span> <span class="s1">&#39;struct1&#39;</span><span class="p">,</span>
  <span class="nx">proto</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;struct2&#39;</span><span class="p">],</span>
  <span class="nx">struct</span><span class="o">:</span> <span class="p">[</span><span class="s1">&#39;struct2&#39;</span><span class="p">]</span>
<span class="p">});</span>

<span class="c1">// &quot;struct2&quot; describes an object that is empty or might contain a &quot;struct1&quot;</span>
<span class="c1">// element associated to the key &quot;key&quot;.</span>
<span class="nx">domino</span><span class="p">.</span><span class="nx">struct</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;struct2&#39;</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">key</span><span class="o">:</span> <span class="s1">&#39;?struct1&#39;</span>
<span class="p">});</span>
</pre>
</div>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-35965604-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>